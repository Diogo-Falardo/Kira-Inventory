/**
 * Generated by orval v7.14.0 🍺
 * Do not edit manually.
 * Kira Inventory API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation } from "@tanstack/react-query";
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult,
} from "@tanstack/react-query";

import type {
  HTTPValidationError,
  RefreshTokenAuthRefreshPostBody,
  Token,
  UserCreate,
  UserLogin,
  UserOut,
} from "../orval.schemas";

import { apiFetcher } from "../../core/api";

/**
 * @summary Registeruser
 */
export const registerUserAuthRegisterPost = (
  userCreate: UserCreate,
  signal?: AbortSignal,
) => {
  return apiFetcher<UserOut>({
    url: `/auth/register`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userCreate,
    signal,
  });
};

export const getRegisterUserAuthRegisterPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof registerUserAuthRegisterPost>>,
    TError,
    { data: UserCreate },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof registerUserAuthRegisterPost>>,
  TError,
  { data: UserCreate },
  TContext
> => {
  const mutationKey = ["registerUserAuthRegisterPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof registerUserAuthRegisterPost>>,
    { data: UserCreate }
  > = (props) => {
    const { data } = props ?? {};

    return registerUserAuthRegisterPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RegisterUserAuthRegisterPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof registerUserAuthRegisterPost>>
>;
export type RegisterUserAuthRegisterPostMutationBody = UserCreate;
export type RegisterUserAuthRegisterPostMutationError = HTTPValidationError;

/**
 * @summary Registeruser
 */
export const useRegisterUserAuthRegisterPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof registerUserAuthRegisterPost>>,
      TError,
      { data: UserCreate },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof registerUserAuthRegisterPost>>,
  TError,
  { data: UserCreate },
  TContext
> => {
  const mutationOptions =
    getRegisterUserAuthRegisterPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Loginuser
 */
export const loginUserAuthLoginPost = (
  userLogin: UserLogin,
  signal?: AbortSignal,
) => {
  return apiFetcher<Token>({
    url: `/auth/login`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: userLogin,
    signal,
  });
};

export const getLoginUserAuthLoginPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof loginUserAuthLoginPost>>,
    TError,
    { data: UserLogin },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof loginUserAuthLoginPost>>,
  TError,
  { data: UserLogin },
  TContext
> => {
  const mutationKey = ["loginUserAuthLoginPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof loginUserAuthLoginPost>>,
    { data: UserLogin }
  > = (props) => {
    const { data } = props ?? {};

    return loginUserAuthLoginPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type LoginUserAuthLoginPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof loginUserAuthLoginPost>>
>;
export type LoginUserAuthLoginPostMutationBody = UserLogin;
export type LoginUserAuthLoginPostMutationError = HTTPValidationError;

/**
 * @summary Loginuser
 */
export const useLoginUserAuthLoginPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof loginUserAuthLoginPost>>,
      TError,
      { data: UserLogin },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof loginUserAuthLoginPost>>,
  TError,
  { data: UserLogin },
  TContext
> => {
  const mutationOptions = getLoginUserAuthLoginPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Refreshtoken
 */
export const refreshTokenAuthRefreshPost = (
  refreshTokenAuthRefreshPostBody: RefreshTokenAuthRefreshPostBody,
  signal?: AbortSignal,
) => {
  return apiFetcher<Token>({
    url: `/auth/refresh`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: refreshTokenAuthRefreshPostBody,
    signal,
  });
};

export const getRefreshTokenAuthRefreshPostMutationOptions = <
  TError = HTTPValidationError,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshTokenAuthRefreshPost>>,
    TError,
    { data: RefreshTokenAuthRefreshPostBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof refreshTokenAuthRefreshPost>>,
  TError,
  { data: RefreshTokenAuthRefreshPostBody },
  TContext
> => {
  const mutationKey = ["refreshTokenAuthRefreshPost"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refreshTokenAuthRefreshPost>>,
    { data: RefreshTokenAuthRefreshPostBody }
  > = (props) => {
    const { data } = props ?? {};

    return refreshTokenAuthRefreshPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RefreshTokenAuthRefreshPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof refreshTokenAuthRefreshPost>>
>;
export type RefreshTokenAuthRefreshPostMutationBody =
  RefreshTokenAuthRefreshPostBody;
export type RefreshTokenAuthRefreshPostMutationError = HTTPValidationError;

/**
 * @summary Refreshtoken
 */
export const useRefreshTokenAuthRefreshPost = <
  TError = HTTPValidationError,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof refreshTokenAuthRefreshPost>>,
      TError,
      { data: RefreshTokenAuthRefreshPostBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof refreshTokenAuthRefreshPost>>,
  TError,
  { data: RefreshTokenAuthRefreshPostBody },
  TContext
> => {
  const mutationOptions =
    getRefreshTokenAuthRefreshPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
